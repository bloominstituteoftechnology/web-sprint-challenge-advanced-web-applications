{"ast":null,"code":"import { l as lib, c as createCommonjsModule } from './fetch-deps.js';\n/**\r\n * Parses a given string into a JSON.\r\n * Does not throw an exception on an invalid JSON string.\r\n */\n\nfunction jsonParse(str) {\n  try {\n    return JSON.parse(str);\n  } catch (error) {\n    return undefined;\n  }\n}\n/**\r\n * Parses a given request/response body based on the `Content-Type` header.\r\n */\n\n\nfunction parseBody(body, headers) {\n  var _a;\n\n  if (body) {\n    // If the intercepted request's body has a JSON Content-Type\n    // parse it into an object, otherwise leave as-is.\n    const hasJsonContent = (_a = headers === null || headers === void 0 ? void 0 : headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.includes('json');\n\n    if (hasJsonContent && typeof body !== 'object') {\n      return jsonParse(body) || body;\n    }\n\n    return body;\n  } // Return whatever falsey body value is given.\n\n\n  return body;\n}\n/**\r\n * Formats a mocked request for introspection in browser's console.\r\n */\n\n\nfunction prepareRequest(req) {\n  return Object.assign(Object.assign({}, req), {\n    headers: req.headers.getAllHeaders()\n  });\n}\n/**\r\n * Formats a mocked response for introspection in browser's console.\r\n */\n\n\nfunction prepareResponse(res) {\n  const responseHeaders = lib.listToHeaders(res.headers);\n  return Object.assign(Object.assign({}, res), {\n    // Parse a response JSON body for preview in the logs\n    body: parseBody(res.body, responseHeaders)\n  });\n}\n\nfunction getTimestamp() {\n  const now = new Date();\n  return [now.getHours(), now.getMinutes(), now.getSeconds()].map(String).map(chunk => chunk.slice(0, 2)).map(chunk => chunk.padStart(2, '0')).join(':');\n}\n/**\r\n * Returns a HEX color for a given response status code number.\r\n */\n\n\nfunction getStatusCodeColor(status) {\n  if (status < 300) {\n    return '#69AB32';\n  }\n\n  if (status < 400) {\n    return '#F0BB4B';\n  }\n\n  return '#E95F5D';\n}\n/**\r\n * Converts a string path to a Regular Expression.\r\n * Transforms path parameters into named RegExp groups.\r\n */\n\n\nconst pathToRegExp = path => {\n  const pattern = path // Escape literal dots\n  .replace(/\\./g, '\\\\.') // Escape literal slashes\n  .replace(/\\//g, '/') // Escape literal question marks\n  .replace(/\\?/g, '\\\\?') // Ignore trailing slashes\n  .replace(/\\/+$/, '') // Replace wildcard with any single character sequence\n  .replace(/\\*+/g, '.+') // Replace parameters with named capturing groups\n  .replace(/:([^\\d|^\\/][a-zA-Z0-9]*(?=(?:\\/|\\\\.)|$))/g, (_, match) => `(?<${match}>.+?)`) // Allow optional trailing slash\n  .concat('(\\\\/|$)');\n  return new RegExp(pattern, 'g');\n};\n/**\r\n * Matches a given url against a path.\r\n */\n\n\nconst match = (path, url) => {\n  const expression = path instanceof RegExp ? path : pathToRegExp(path);\n  const match = expression.exec(url) || false; // Matches in strict mode: match string should equal to input (url)\n  // Otherwise loose matches will be considered truthy:\n  // match('/messages/:id', '/messages/123/users') // true\n\n  const matches = path instanceof RegExp ? !!match : !!match && match[0] === match.input;\n  return {\n    matches,\n    params: match && matches ? match.groups || null : null\n  };\n};\n\nvar getCleanUrl_1 = createCommonjsModule(function (module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  /**\n   * Removes query parameters and hashes from a given URL.\n   */\n\n  function getCleanUrl(url, isAbsolute) {\n    if (isAbsolute === void 0) {\n      isAbsolute = true;\n    }\n\n    return [isAbsolute && url.origin, url.pathname].filter(Boolean).join('');\n  }\n\n  exports.getCleanUrl = getCleanUrl;\n});\n/**\r\n * Returns an absolute URL based on the given relative URL, if possible.\r\n * Ignores regular expressions.\r\n */\n\nconst getAbsoluteUrl = mask => {\n  // Global `location` object doesn't exist in Node.\n  // Relative request predicate URL cannot become absolute.\n  const hasLocation = typeof location !== 'undefined';\n  return typeof mask === 'string' && mask.startsWith('/') ? `${hasLocation ? location.origin : ''}${mask}` : mask;\n};\n/**\r\n * Converts a given request handler mask into a URL, if given a valid URL string.\r\n */\n\n\nfunction getUrlByMask(mask) {\n  /**\r\n   * If a string mask contains an asterisk (wildcard), return it as-is.\r\n   * Converting a URL-like path string into an actual URL is misleading.\r\n   * @see https://github.com/mswjs/msw/issues/357\r\n   */\n  if (mask instanceof RegExp || mask.includes('*')) {\n    return mask;\n  }\n\n  try {\n    // Attempt to create a URL instance out of the mask string.\n    // Resolve mask to an absolute URL, because even a valid relative URL\n    // cannot be converted into the URL instance (required absolute URL only).\n    return new URL(getAbsoluteUrl(mask));\n  } catch (error) {\n    // Otherwise, the mask is a path string.\n    return mask;\n  }\n}\n\nfunction getCleanMask(resolvedMask) {\n  return resolvedMask instanceof URL ? getCleanUrl_1.getCleanUrl(resolvedMask) : resolvedMask instanceof RegExp ? resolvedMask : getAbsoluteUrl(resolvedMask);\n}\n/**\r\n * Returns the result of matching given request URL\r\n * against a mask.\r\n */\n\n\nfunction matchRequestUrl(url, mask) {\n  const resolvedMask = getUrlByMask(mask);\n  const cleanMask = getCleanMask(resolvedMask);\n  const cleanRequestUrl = getCleanUrl_1.getCleanUrl(url);\n  return match(cleanMask, cleanRequestUrl);\n}\n\nexport { prepareRequest as a, prepareResponse as b, getTimestamp as c, getStatusCodeColor as d, getUrlByMask as g, jsonParse as j, matchRequestUrl as m, parseBody as p };","map":{"version":3,"sources":["C:/Users/Admin2/OneDrive/Lambda School/Web_3.3/Sprint/web-sprint-challenge-advanced-web-applications/client/node_modules/msw/lib/esm/matchRequestUrl-deps.js"],"names":["l","lib","c","createCommonjsModule","jsonParse","str","JSON","parse","error","undefined","parseBody","body","headers","_a","hasJsonContent","get","includes","prepareRequest","req","Object","assign","getAllHeaders","prepareResponse","res","responseHeaders","listToHeaders","getTimestamp","now","Date","getHours","getMinutes","getSeconds","map","String","chunk","slice","padStart","join","getStatusCodeColor","status","pathToRegExp","path","pattern","replace","_","match","concat","RegExp","url","expression","exec","matches","input","params","groups","getCleanUrl_1","module","exports","defineProperty","value","getCleanUrl","isAbsolute","origin","pathname","filter","Boolean","getAbsoluteUrl","mask","hasLocation","location","startsWith","getUrlByMask","URL","getCleanMask","resolvedMask","matchRequestUrl","cleanMask","cleanRequestUrl","a","b","d","g","j","m","p"],"mappings":"AAAA,SAASA,CAAC,IAAIC,GAAd,EAAmBC,CAAC,IAAIC,oBAAxB,QAAoD,iBAApD;AAEA;AACA;AACA;AACA;;AACA,SAASC,SAAT,CAAmBC,GAAnB,EAAwB;AACpB,MAAI;AACA,WAAOC,IAAI,CAACC,KAAL,CAAWF,GAAX,CAAP;AACH,GAFD,CAGA,OAAOG,KAAP,EAAc;AACV,WAAOC,SAAP;AACH;AACJ;AAED;AACA;AACA;;;AACA,SAASC,SAAT,CAAmBC,IAAnB,EAAyBC,OAAzB,EAAkC;AAC9B,MAAIC,EAAJ;;AACA,MAAIF,IAAJ,EAAU;AACN;AACA;AACA,UAAMG,cAAc,GAAG,CAACD,EAAE,GAAGD,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACG,GAAR,CAAY,cAAZ,CAAxD,MAAyF,IAAzF,IAAiGF,EAAE,KAAK,KAAK,CAA7G,GAAiH,KAAK,CAAtH,GAA0HA,EAAE,CAACG,QAAH,CAAY,MAAZ,CAAjJ;;AACA,QAAIF,cAAc,IAAI,OAAOH,IAAP,KAAgB,QAAtC,EAAgD;AAC5C,aAAOP,SAAS,CAACO,IAAD,CAAT,IAAmBA,IAA1B;AACH;;AACD,WAAOA,IAAP;AACH,GAV6B,CAW9B;;;AACA,SAAOA,IAAP;AACH;AAED;AACA;AACA;;;AACA,SAASM,cAAT,CAAwBC,GAAxB,EAA6B;AACzB,SAAOC,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBF,GAAlB,CAAd,EAAsC;AAAEN,IAAAA,OAAO,EAAEM,GAAG,CAACN,OAAJ,CAAYS,aAAZ;AAAX,GAAtC,CAAP;AACH;AAED;AACA;AACA;;;AACA,SAASC,eAAT,CAAyBC,GAAzB,EAA8B;AAC1B,QAAMC,eAAe,GAAGvB,GAAG,CAACwB,aAAJ,CAAkBF,GAAG,CAACX,OAAtB,CAAxB;AACA,SAAOO,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBG,GAAlB,CAAd,EAAsC;AACzC;AACAZ,IAAAA,IAAI,EAAED,SAAS,CAACa,GAAG,CAACZ,IAAL,EAAWa,eAAX;AAF0B,GAAtC,CAAP;AAGH;;AAED,SAASE,YAAT,GAAwB;AACpB,QAAMC,GAAG,GAAG,IAAIC,IAAJ,EAAZ;AACA,SAAO,CAACD,GAAG,CAACE,QAAJ,EAAD,EAAiBF,GAAG,CAACG,UAAJ,EAAjB,EAAmCH,GAAG,CAACI,UAAJ,EAAnC,EACFC,GADE,CACEC,MADF,EAEFD,GAFE,CAEGE,KAAD,IAAWA,KAAK,CAACC,KAAN,CAAY,CAAZ,EAAe,CAAf,CAFb,EAGFH,GAHE,CAGGE,KAAD,IAAWA,KAAK,CAACE,QAAN,CAAe,CAAf,EAAkB,GAAlB,CAHb,EAIFC,IAJE,CAIG,GAJH,CAAP;AAKH;AAED;AACA;AACA;;;AACA,SAASC,kBAAT,CAA4BC,MAA5B,EAAoC;AAChC,MAAIA,MAAM,GAAG,GAAb,EAAkB;AACd,WAAO,SAAP;AACH;;AACD,MAAIA,MAAM,GAAG,GAAb,EAAkB;AACd,WAAO,SAAP;AACH;;AACD,SAAO,SAAP;AACH;AAED;AACA;AACA;AACA;;;AACA,MAAMC,YAAY,GAAIC,IAAD,IAAU;AAC3B,QAAMC,OAAO,GAAGD,IAAI,CAChB;AADgB,GAEfE,OAFW,CAEH,KAFG,EAEI,KAFJ,EAGZ;AAHY,GAIXA,OAJW,CAIH,KAJG,EAII,GAJJ,EAKZ;AALY,GAMXA,OANW,CAMH,KANG,EAMI,KANJ,EAOZ;AAPY,GAQXA,OARW,CAQH,MARG,EAQK,EARL,EASZ;AATY,GAUXA,OAVW,CAUH,MAVG,EAUK,IAVL,EAWZ;AAXY,GAYXA,OAZW,CAYH,2CAZG,EAY0C,CAACC,CAAD,EAAIC,KAAJ,KAAe,MAAKA,KAAM,OAZpE,EAaZ;AAbY,GAcXC,MAdW,CAcJ,SAdI,CAAhB;AAeA,SAAO,IAAIC,MAAJ,CAAWL,OAAX,EAAoB,GAApB,CAAP;AACH,CAjBD;AAmBA;AACA;AACA;;;AACA,MAAMG,KAAK,GAAG,CAACJ,IAAD,EAAOO,GAAP,KAAe;AACzB,QAAMC,UAAU,GAAGR,IAAI,YAAYM,MAAhB,GAAyBN,IAAzB,GAAgCD,YAAY,CAACC,IAAD,CAA/D;AACA,QAAMI,KAAK,GAAGI,UAAU,CAACC,IAAX,CAAgBF,GAAhB,KAAwB,KAAtC,CAFyB,CAGzB;AACA;AACA;;AACA,QAAMG,OAAO,GAAGV,IAAI,YAAYM,MAAhB,GAAyB,CAAC,CAACF,KAA3B,GAAmC,CAAC,CAACA,KAAF,IAAWA,KAAK,CAAC,CAAD,CAAL,KAAaA,KAAK,CAACO,KAAjF;AACA,SAAO;AACHD,IAAAA,OADG;AAEHE,IAAAA,MAAM,EAAER,KAAK,IAAIM,OAAT,GAAmBN,KAAK,CAACS,MAAN,IAAgB,IAAnC,GAA0C;AAF/C,GAAP;AAIH,CAXD;;AAaA,IAAIC,aAAa,GAAGpD,oBAAoB,CAAC,UAAUqD,MAAV,EAAkBC,OAAlB,EAA2B;AACpEtC,EAAAA,MAAM,CAACuC,cAAP,CAAsBD,OAAtB,EAA+B,YAA/B,EAA6C;AAAEE,IAAAA,KAAK,EAAE;AAAT,GAA7C;AACA;AACA;AACA;;AACA,WAASC,WAAT,CAAqBZ,GAArB,EAA0Ba,UAA1B,EAAsC;AAClC,QAAIA,UAAU,KAAK,KAAK,CAAxB,EAA2B;AAAEA,MAAAA,UAAU,GAAG,IAAb;AAAoB;;AACjD,WAAO,CAACA,UAAU,IAAIb,GAAG,CAACc,MAAnB,EAA2Bd,GAAG,CAACe,QAA/B,EAAyCC,MAAzC,CAAgDC,OAAhD,EAAyD5B,IAAzD,CAA8D,EAA9D,CAAP;AACH;;AACDoB,EAAAA,OAAO,CAACG,WAAR,GAAsBA,WAAtB;AACC,CAVuC,CAAxC;AAYA;AACA;AACA;AACA;;AACA,MAAMM,cAAc,GAAIC,IAAD,IAAU;AAC7B;AACA;AACA,QAAMC,WAAW,GAAG,OAAOC,QAAP,KAAoB,WAAxC;AACA,SAAO,OAAOF,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,CAACG,UAAL,CAAgB,GAAhB,CAA5B,GACA,GAAEF,WAAW,GAAGC,QAAQ,CAACP,MAAZ,GAAqB,EAAG,GAAEK,IAAK,EAD5C,GAEDA,IAFN;AAGH,CAPD;AASA;AACA;AACA;;;AACA,SAASI,YAAT,CAAsBJ,IAAtB,EAA4B;AACxB;AACJ;AACA;AACA;AACA;AACI,MAAIA,IAAI,YAAYpB,MAAhB,IAA0BoB,IAAI,CAACnD,QAAL,CAAc,GAAd,CAA9B,EAAkD;AAC9C,WAAOmD,IAAP;AACH;;AACD,MAAI;AACA;AACA;AACA;AACA,WAAO,IAAIK,GAAJ,CAAQN,cAAc,CAACC,IAAD,CAAtB,CAAP;AACH,GALD,CAMA,OAAO3D,KAAP,EAAc;AACV;AACA,WAAO2D,IAAP;AACH;AACJ;;AAED,SAASM,YAAT,CAAsBC,YAAtB,EAAoC;AAChC,SAAOA,YAAY,YAAYF,GAAxB,GACDjB,aAAa,CAACK,WAAd,CAA0Bc,YAA1B,CADC,GAEDA,YAAY,YAAY3B,MAAxB,GACI2B,YADJ,GAEIR,cAAc,CAACQ,YAAD,CAJxB;AAKH;AAED;AACA;AACA;AACA;;;AACA,SAASC,eAAT,CAAyB3B,GAAzB,EAA8BmB,IAA9B,EAAoC;AAChC,QAAMO,YAAY,GAAGH,YAAY,CAACJ,IAAD,CAAjC;AACA,QAAMS,SAAS,GAAGH,YAAY,CAACC,YAAD,CAA9B;AACA,QAAMG,eAAe,GAAGtB,aAAa,CAACK,WAAd,CAA0BZ,GAA1B,CAAxB;AACA,SAAOH,KAAK,CAAC+B,SAAD,EAAYC,eAAZ,CAAZ;AACH;;AAED,SAAS5D,cAAc,IAAI6D,CAA3B,EAA8BxD,eAAe,IAAIyD,CAAjD,EAAoDrD,YAAY,IAAIxB,CAApE,EAAuEoC,kBAAkB,IAAI0C,CAA7F,EAAgGT,YAAY,IAAIU,CAAhH,EAAmH7E,SAAS,IAAI8E,CAAhI,EAAmIP,eAAe,IAAIQ,CAAtJ,EAAyJzE,SAAS,IAAI0E,CAAtK","sourcesContent":["import { l as lib, c as createCommonjsModule } from './fetch-deps.js';\n\n/**\r\n * Parses a given string into a JSON.\r\n * Does not throw an exception on an invalid JSON string.\r\n */\r\nfunction jsonParse(str) {\r\n    try {\r\n        return JSON.parse(str);\r\n    }\r\n    catch (error) {\r\n        return undefined;\r\n    }\r\n}\n\n/**\r\n * Parses a given request/response body based on the `Content-Type` header.\r\n */\r\nfunction parseBody(body, headers) {\r\n    var _a;\r\n    if (body) {\r\n        // If the intercepted request's body has a JSON Content-Type\r\n        // parse it into an object, otherwise leave as-is.\r\n        const hasJsonContent = (_a = headers === null || headers === void 0 ? void 0 : headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.includes('json');\r\n        if (hasJsonContent && typeof body !== 'object') {\r\n            return jsonParse(body) || body;\r\n        }\r\n        return body;\r\n    }\r\n    // Return whatever falsey body value is given.\r\n    return body;\r\n}\n\n/**\r\n * Formats a mocked request for introspection in browser's console.\r\n */\r\nfunction prepareRequest(req) {\r\n    return Object.assign(Object.assign({}, req), { headers: req.headers.getAllHeaders() });\r\n}\n\n/**\r\n * Formats a mocked response for introspection in browser's console.\r\n */\r\nfunction prepareResponse(res) {\r\n    const responseHeaders = lib.listToHeaders(res.headers);\r\n    return Object.assign(Object.assign({}, res), { \r\n        // Parse a response JSON body for preview in the logs\r\n        body: parseBody(res.body, responseHeaders) });\r\n}\n\nfunction getTimestamp() {\r\n    const now = new Date();\r\n    return [now.getHours(), now.getMinutes(), now.getSeconds()]\r\n        .map(String)\r\n        .map((chunk) => chunk.slice(0, 2))\r\n        .map((chunk) => chunk.padStart(2, '0'))\r\n        .join(':');\r\n}\n\n/**\r\n * Returns a HEX color for a given response status code number.\r\n */\r\nfunction getStatusCodeColor(status) {\r\n    if (status < 300) {\r\n        return '#69AB32';\r\n    }\r\n    if (status < 400) {\r\n        return '#F0BB4B';\r\n    }\r\n    return '#E95F5D';\r\n}\n\n/**\r\n * Converts a string path to a Regular Expression.\r\n * Transforms path parameters into named RegExp groups.\r\n */\r\nconst pathToRegExp = (path) => {\r\n    const pattern = path\r\n        // Escape literal dots\r\n        .replace(/\\./g, '\\\\.')\r\n        // Escape literal slashes\r\n        .replace(/\\//g, '/')\r\n        // Escape literal question marks\r\n        .replace(/\\?/g, '\\\\?')\r\n        // Ignore trailing slashes\r\n        .replace(/\\/+$/, '')\r\n        // Replace wildcard with any single character sequence\r\n        .replace(/\\*+/g, '.+')\r\n        // Replace parameters with named capturing groups\r\n        .replace(/:([^\\d|^\\/][a-zA-Z0-9]*(?=(?:\\/|\\\\.)|$))/g, (_, match) => `(?<${match}>.+?)`)\r\n        // Allow optional trailing slash\r\n        .concat('(\\\\/|$)');\r\n    return new RegExp(pattern, 'g');\r\n};\n\n/**\r\n * Matches a given url against a path.\r\n */\r\nconst match = (path, url) => {\r\n    const expression = path instanceof RegExp ? path : pathToRegExp(path);\r\n    const match = expression.exec(url) || false;\r\n    // Matches in strict mode: match string should equal to input (url)\r\n    // Otherwise loose matches will be considered truthy:\r\n    // match('/messages/:id', '/messages/123/users') // true\r\n    const matches = path instanceof RegExp ? !!match : !!match && match[0] === match.input;\r\n    return {\r\n        matches,\r\n        params: match && matches ? match.groups || null : null,\r\n    };\r\n};\n\nvar getCleanUrl_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Removes query parameters and hashes from a given URL.\n */\nfunction getCleanUrl(url, isAbsolute) {\n    if (isAbsolute === void 0) { isAbsolute = true; }\n    return [isAbsolute && url.origin, url.pathname].filter(Boolean).join('');\n}\nexports.getCleanUrl = getCleanUrl;\n});\n\n/**\r\n * Returns an absolute URL based on the given relative URL, if possible.\r\n * Ignores regular expressions.\r\n */\r\nconst getAbsoluteUrl = (mask) => {\r\n    // Global `location` object doesn't exist in Node.\r\n    // Relative request predicate URL cannot become absolute.\r\n    const hasLocation = typeof location !== 'undefined';\r\n    return typeof mask === 'string' && mask.startsWith('/')\r\n        ? `${hasLocation ? location.origin : ''}${mask}`\r\n        : mask;\r\n};\n\n/**\r\n * Converts a given request handler mask into a URL, if given a valid URL string.\r\n */\r\nfunction getUrlByMask(mask) {\r\n    /**\r\n     * If a string mask contains an asterisk (wildcard), return it as-is.\r\n     * Converting a URL-like path string into an actual URL is misleading.\r\n     * @see https://github.com/mswjs/msw/issues/357\r\n     */\r\n    if (mask instanceof RegExp || mask.includes('*')) {\r\n        return mask;\r\n    }\r\n    try {\r\n        // Attempt to create a URL instance out of the mask string.\r\n        // Resolve mask to an absolute URL, because even a valid relative URL\r\n        // cannot be converted into the URL instance (required absolute URL only).\r\n        return new URL(getAbsoluteUrl(mask));\r\n    }\r\n    catch (error) {\r\n        // Otherwise, the mask is a path string.\r\n        return mask;\r\n    }\r\n}\n\nfunction getCleanMask(resolvedMask) {\r\n    return resolvedMask instanceof URL\r\n        ? getCleanUrl_1.getCleanUrl(resolvedMask)\r\n        : resolvedMask instanceof RegExp\r\n            ? resolvedMask\r\n            : getAbsoluteUrl(resolvedMask);\r\n}\n\n/**\r\n * Returns the result of matching given request URL\r\n * against a mask.\r\n */\r\nfunction matchRequestUrl(url, mask) {\r\n    const resolvedMask = getUrlByMask(mask);\r\n    const cleanMask = getCleanMask(resolvedMask);\r\n    const cleanRequestUrl = getCleanUrl_1.getCleanUrl(url);\r\n    return match(cleanMask, cleanRequestUrl);\r\n}\n\nexport { prepareRequest as a, prepareResponse as b, getTimestamp as c, getStatusCodeColor as d, getUrlByMask as g, jsonParse as j, matchRequestUrl as m, parseBody as p };\n"]},"metadata":{},"sourceType":"module"}